<html>
<head>
	<title>BlipKit</title>
	<style type="text/css">
		*, *:after, *:before {
			box-sizing: border-box;
		}

		html, body {
			width: 100%;
			height: 100%;
			margin: 0;
			font-family: Helvetica, sans-serif;
			font-size: 15px;
		}

		.wrapper {
			height: 100%;
			display: flex;
			flex-direction: column;
		}

		.controls-wrapper {
			flex: none;
			display: flex;
		}

		.controls-wrapper .control {
			padding: 0.5rem;
			display: block;
			flex: 1;
		}

		.screen-wrapper {
			flex: 1;
			position: relative;
		}

		svg {
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			display: block;
			position: absolute;
		}

		#log {
			display: none;
		}
	</style>
</head>
<body>

<div class="wrapper">
	<div class="controls-wrapper">
		<label class="control"> Waveform: <select name="waveform">
			<option value="1">Square</option>
			<option value="2">Triangle</option>
			<option value="3">Noise</option>
			<option value="4">Sawtooth</option>
			<option value="5">Sine</option>
		</select></label>
	</div>
	<div class="screen-wrapper">
		<svg viewBox="0 0 12 8" preserveAspectRatio="none" id="screen"></svg>
	</div>
</div>

<script>

class BlipKitController {
	constructor(module) {
		const numFrames = 1024;
		const numChannels = 2;

		this.module = module;
		this.context = new (window.AudioContext || window.webkitAudioContext)();
		this.source = this.context.createBufferSource();
		this.generatorNode = this.context.createScriptProcessor(numFrames, numChannels, numChannels);

		this.generatorNode.onaudioprocess = (audioProcessingEvent) => {
			const audioBuffer = this.module._getBuffer();
			const inputBuffer = audioProcessingEvent.inputBuffer;
			const outputBuffer = audioProcessingEvent.outputBuffer;

			this.generate(inputBuffer.length);

			for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
				const outputData = outputBuffer.getChannelData(channel);
				const channelData = this.heapFloat32Array(audioBuffer, inputBuffer.length * channel, inputBuffer.length);

				outputData.set(channelData);
			}
		}
	}

	connectNode() {
		this.source.connect(this.generatorNode);
		this.generatorNode.connect(this.context.destination);
	}

	disconnectNode() {
		this.source.connect(this.generatorNode);
		this.generatorNode.connect(this.context.destination);
	}

	generate(length) {
		return this.module._generate(length);
	}

	heapFloat32Array(array, offset, length) {
		const memory = this.module.HEAPF32;
		const offsetStart = array / memory.BYTES_PER_ELEMENT + offset;
		const offsetEnd = offsetStart + length;

		return memory.subarray(offsetStart, offsetEnd);
	}

	init() {
		const module = this.module;
		let down = false;
		let arpType = 0;

		setTimeout(() => {
			this.connectNode();
		}, 10);

		function setNoteFromEvent(e) {
			const width = window.innerWidth;
			const height = window.innerHeight;
			const x = Math.floor(e.clientX / width * 12);
			const y = 7 - Math.floor(e.clientY / height * 8);
			const tone = y * 12 + x;
			const toneIdx = tone % 12;
			let newArpType = 0;

			if ([0, 3, 4, 5, 7].indexOf(toneIdx) !== -1) {
				newArpType = 1;
			}
			else {
				newArpType = 2;
			}

			/*if (newArpType !== arpType) {
				arpType = newArpType;

				switch (arpType) {
					case 1: {
						module._setMajorArpeggio();
						break;
					}
					case 2: {
						module._setMinorArpeggio();
						break;
					}
				}
			}*/

			module._setNote(tone);
		}

		let svg = document.querySelector('#screen');

		svg.addEventListener('mousedown', function (e) {
			down = true;
			setNoteFromEvent(e);
			e.preventDefault();
		});

		svg.addEventListener('mousemove', function (e) {
			if (down) {
				setNoteFromEvent(e);
			}
		});

		document.addEventListener('mouseup', function () {
			down = false;
			module._setNote(-1);
		});
	}
}

const waveformShift = 4 << 12;
const BK_SQUARE     = waveformShift + 1;
const BK_TRIANGLE   = waveformShift + 2;
const BK_NOISE      = waveformShift + 3;
const BK_SAWTOOTH   = waveformShift + 4;
const BK_SINE       = waveformShift + 5;
const BK_CUSTOM     = waveformShift + 6;
const BK_SAMPLE     = waveformShift + 7;

let BlipKit = {};
let controller = new BlipKitController(BlipKit);

let app = {
	ready: function () {
		controller.init();
	},
};

let screen = document.querySelector('#screen');

for (let x = 0; x < 12; x++) {
	for (let y = 0; y < 8; y++) {
		let i = y * 12 + x;
		let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
		rect.setAttribute('width', '0.95px');
		rect.setAttribute('height', '0.95px');
		rect.setAttribute('x', (x + 0.025) + 'px');
		rect.setAttribute('y', (y + 0.025) + 'px');
		rect.setAttribute('fill', '#000');
		rect.setAttribute('opacity', ((y + 1) / 8) * 0.25);
		screen.appendChild(rect);
	}
}

document.querySelector('select[name=waveform]').addEventListener('change', function (e) {
	const value = waveformShift + parseInt(this.selectedOptions[0].value);
	controller.module._setWaveform(value);
});

</script>
<script src="blipkit.js"></script>

</body>
</html>
